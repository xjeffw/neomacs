1	(fboundp 'with-syntax-table)	OK t
2	(special-form-p 'with-syntax-table)	OK nil
3	(with-syntax-table (make-syntax-table) :ok)	OK :ok
4	(with-syntax-table (make-syntax-table) 1 2 3)	OK 3
5	(let ((x 0)) (with-syntax-table (progn (setq x (1+ x)) (make-syntax-table)) x))	OK 1
6	(condition-case err (with-syntax-table) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
7	(condition-case err (with-syntax-table (progn (signal 'error '("boom"))) 1) (error (car err)))	OK error
8	(let ((orig (syntax-table)) (tmp (make-syntax-table))) (list (with-syntax-table tmp (eq (syntax-table) tmp)) (eq (syntax-table) orig)))	OK (t t)
9	(let ((orig (syntax-table)) (tmp (make-syntax-table))) (list (condition-case err (with-syntax-table tmp (signal 'error '("boom"))) (error (car err))) (eq (syntax-table) orig)))	OK (error t)
10	(condition-case err (with-syntax-table 1 :ok) (error (list (car err) (cadr err))))	OK (wrong-type-argument syntax-table-p)
11	(fboundp 'track-mouse)	OK t
12	(special-form-p 'track-mouse)	OK nil
13	(track-mouse :a :b)	OK :b
14	(track-mouse)	OK nil
15	(let ((x 0)) (track-mouse (setq x 1) (setq x (+ x 1)) x))	OK 2
16	(condition-case err (track-mouse (signal 'error '("boom"))) (error (car err)))	OK error
