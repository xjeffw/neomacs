1	(fboundp 'category-table)	OK t
2	(fboundp 'standard-category-table)	OK t
3	(fboundp 'set-category-table)	OK t
4	(fboundp 'make-category-table)	OK t
5	(category-table-p (category-table))	OK t
6	(category-table-p (standard-category-table))	OK t
7	(let ((tbl (make-category-table))) (and (category-table-p tbl) (eq (set-category-table tbl) tbl)))	OK t
8	(let ((orig (category-table)) (tbl (make-category-table))) (set-category-table tbl) (prog1 (eq (category-table) tbl) (set-category-table orig)))	OK t
9	(condition-case err (set-category-table 1) (error (list (car err) (cadr err))))	OK (wrong-type-argument category-table-p)
10	(condition-case err (category-table nil) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
11	(let ((orig (category-table)) (tbl (make-category-table))) (set-category-table tbl) (prog1 (let ((after (set-category-table nil))) (list (category-table-p after) (eq after (category-table)) (eq after (standard-category-table)))) (set-category-table orig)))	OK (t t nil)
12	(let ((orig (category-table))) (prog1 (let ((after (set-category-table nil))) (eq after (standard-category-table))) (set-category-table orig)))	OK nil
