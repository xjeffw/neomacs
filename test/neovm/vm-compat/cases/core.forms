; Basic arithmetic and list mutation behavior
(+ 1 2)
(let ((x 1)) (setq x (+ x 2)) x)
(let ((lst '(1 2))) (setcar lst 9) lst)

; Control flow and error behavior
(catch 'tag (throw 'tag 42))
(condition-case e (/ 1 0) (arith-error 'div-zero))

; Dynamic-binding-sensitive shape (lexical-binding=nil in this oracle)
(let ((x 1))
  (let ((f (lambda () x)))
    (let ((x 2))
      (funcall f))))

; Function namespace and core list/branch primitives
(progn
  (defun add2 (a b) (+ a b))
  (add2 5 7))
(if (eq (car (cons 1 nil)) 1) (list 9 8) nil)
(cdr '(1 2 3))
(if nil 1 2)

; Sequential bindings and structural equality
(let* ((x 1) (y (+ x 2))) (if (equal (list x y) '(1 3)) y 0))
(let ((x '(1 2 3))) (setcdr x '(9 10)) x)
(funcall 'equal '(1 (2 3)) '(1 (2 3)))

; Non-local exits with cleanup guarantees
(let ((x 0)) (condition-case e (unwind-protect (/ 1 0) (setq x 7)) (arith-error x)))
(condition-case e (unwind-protect 1 (/ 1 0)) (arith-error 'cleanup-failed))
