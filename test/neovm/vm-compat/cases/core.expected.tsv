1	(+ 1 2)	OK 3
2	(let ((x 1)) (setq x (+ x 2)) x)	OK 3
3	(let ((lst '(1 2))) (setcar lst 9) lst)	OK (9 2)
4	(catch 'tag (throw 'tag 42))	OK 42
5	(condition-case e (/ 1 0) (arith-error 'div-zero))	OK div-zero
6	(let ((x 1)) (let ((f (lambda nil x))) (let ((x 2)) (funcall f))))	OK 2
7	(progn (defun add2 (a b) (+ a b)) (add2 5 7))	OK 12
8	(if (eq (car (cons 1 nil)) 1) (list 9 8) nil)	OK (9 8)
9	(cdr '(1 2 3))	OK (2 3)
10	(if nil 1 2)	OK 2
11	(let* ((x 1) (y (+ x 2))) (if (equal (list x y) '(1 3)) y 0))	OK 3
12	(let ((x '(1 2 3))) (setcdr x '(9 10)) x)	OK (1 9 10)
13	(funcall 'equal '(1 (2 3)) '(1 (2 3)))	OK t
14	(let ((x 0)) (condition-case e (unwind-protect (/ 1 0) (setq x 7)) (arith-error x)))	OK 7
15	(condition-case e (unwind-protect 1 (/ 1 0)) (arith-error 'cleanup-failed))	OK cleanup-failed
